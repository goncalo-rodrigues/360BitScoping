#! /usr/bin/env python
import dpkt
import socket
import sys, getopt
from tracker_filter import tracker_filter, print_output

def mac_addr(address):
    """Convert a MAC address to a readable/printable string

       Args:
           address (str): a MAC address in hex form (e.g. '\x01\x02\x03\x04\x05\x06')
       Returns:
           str: Printable/readable MAC address
    """
    return ':'.join('%02x' % ord(b) for b in address)


def inet_to_str(inet):
    """Convert inet object to a string

        Args:
            inet (inet struct): inet network address
        Returns:
            str: Printable/readable IP address
    """
    # First try ipv4 and then ipv6
    try:
        return socket.inet_ntop(socket.AF_INET, inet)
    except ValueError:
        return socket.inet_ntop(socket.AF_INET6, inet)


def main(argv):
    output_file_path = ""
    try:
        opts, args = getopt.getopt(argv, "ho:", ["help"])
    except getopt.GetoptError:
        print 'for help use -h option'
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print 'Help\nUsage: 360.py <options> <inputfile>\n\
where possible options include:\n\
-h\t\tShow this dialog\n\
-o <file>\tSave all detected packets to file'

            sys.exit()
        if opt == '-o':
            output_file_path = arg
    if len(args) == 0:
        print 'Missing argument: input capture file'
        sys.exit()

    f = open(args[0])
    if output_file_path != "":
        output_f = open(output_file_path, 'w+')
        out_pcap = dpkt.pcap.Writer(output_f)
    else:
        out_pcap = None
        output_f = None
    pcap = dpkt.pcap.Reader(f)

    filters = [tracker_filter]
    # For each packet in the pcap process the contents
    for timestamp, buf in pcap:
        packet_already_saved = False
        eth = dpkt.ethernet.Ethernet(buf)
        # Make sure the Ethernet frame contains an IP packet
        if not isinstance(eth.data, dpkt.ip.IP):
            # print 'Non IP Packet type not supported %s\n' % eth.data.__class__.__name__
            continue

        ip = eth.data

        do_not_fragment = bool(ip.off & dpkt.ip.IP_DF)
        more_fragments = bool(ip.off & dpkt.ip.IP_MF)
        fragment_offset = ip.off & dpkt.ip.IP_OFFMASK
        pkt = ip.data

        for filt in filters:
            is_torrent, output = filt(pkt)
            if is_torrent:
                protocol_str = "UNK"
                if isinstance(pkt, dpkt.tcp.TCP):
                    protocol_str = "TCP"
                elif isinstance(pkt, dpkt.udp.UDP):
                    protocol_str = "UDP"
                filter_name = filt.__name__
                sport, dport = "unk_port", "unk_port"
                try:
                    sport = pkt.sport
                    dport = pkt.dport
                except AttributeError:
                    pass
                if out_pcap is not None and not packet_already_saved:
                    out_pcap.writepkt(buf, timestamp)
                    packet_already_saved = True
                # Print out the info
                print 'Packet detected by %s' % filter_name
                print '%s: %s:%s -> %s:%s   (len=%d)' % \
                      (protocol_str, inet_to_str(ip.src), sport, inet_to_str(ip.dst), dport, ip.len)
                print 'Output generated by filter: %s\n' % print_output(output, sport)

    try:
        f.close()
        output_f.close()
    except:
        pass
if __name__ == "__main__":
    main(sys.argv[1:])
